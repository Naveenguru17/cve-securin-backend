const express = require('express');
const mongoose = require('mongoose');
const axios = require('axios');
const cors = require('cors');

const app = express();
app.use(express.json());
app.use(cors());

mongoose.connect('mongodb://localhost:27017/cveDatabase', { useNewUrlParser: true, useUnifiedTopology: true });
const db = mongoose.connection;
db.on('error', console.error.bind(console, 'MongoDB connection error:'));

const cveSchema = new mongoose.Schema({
    cve_id: String,
    sourceIdentifier: String,
    published: Date,
    lastModified: Date,
    vulnStatus: String,
    descriptions: [{
        lang: String,
        value: String
    }],
    metrics: {
        cvssMetricV2: [{
            cvssData: {
                vectorString:String,
                accessVector: String,
                accessComplexity: String,
                authentication: String,
                confidentialityImpact: String,
                integrityImpact: String,
                availabilityImpact: String,
            },
            baseSeverity: String,
            exploitabilityScore: Number,
            impactScore: Number
        }]
    },
    configurations: [{
        nodes: [{
            cpeMatch: [{
                vulnerable: Boolean,
                criteria: String,
                matchCriteriaId: String
            }]
        }]
    }],
});

const CVE = mongoose.model('CVE', cveSchema);

const formatDate = (dateString) => {
    const date = new Date(dateString);
    const options = { year: 'numeric', month: 'short', day: 'numeric' };
    return date.toLocaleDateString('en-US', options);
};

app.get('/api/cves/:cve_id', async (req, res) => {
    try {
        const cveId = req.params.cve_id;

        const cveDetails = await CVE.findOne({ cve_id: cveId });

        if (!cveDetails) {
            return res.status(404).json({ error: 'CVE not found' });
        }
      

        res.json({ message: 'success', data: cveDetails });

    } catch (error) {
        console.error('Error fetching CVE details:', error);
        res.status(500).json({ error: 'An internal server error occurred' });
    }
});

app.get('/api/cves/count', async (req, res) => {
    try {
        const count = await CVE.countDocuments();
        res.json({ message: 'success', count });
    } catch (error) {
        console.error('Error counting documents:', error);
        res.status(500).json({ error: 'An internal server error occurred' });
    }
});

app.get('/api/cves', async (req, res) => {
    try {
        const baseUrl = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
        let page = req.query.page || 1;
        let pageSize = req.query.pageSize || 10; 
        let offset = (page - 1) * pageSize;

        const response = await axios.get(`${baseUrl}?startIndex=${offset}&resultsPerPage=${pageSize}`, {
            timeout: 150000
        });
        
        const data = response.data;
        const vulnerabilities = data.vulnerabilities;

        await CVE.deleteMany({});

        const cveDataArray = [];

        for (const vulnerability of vulnerabilities) {   

            const configurations = vulnerability?.cve?.configurations?.map(configuration => ({
                nodes: configuration.nodes?.map(node => ({
                    cpeMatch: node.cpeMatch?.map(cpeMatch => ({
                        vulnerable: cpeMatch?.vulnerable,
                        criteria: cpeMatch?.criteria,
                        matchCriteriaId: cpeMatch?.matchCriteriaId
                    }))
                }))
            }));
            

            const cveData = {
                cve_id: vulnerability?.cve?.id,
                sourceIdentifier: vulnerability?.cve?.sourceIdentifier,
                published: formatDate(vulnerability?.cve?.published),
                lastModified: new Date(vulnerability?.cve?.lastModified),
                vulnStatus: vulnerability?.cve?.vulnStatus,
                descriptions: vulnerability?.cve?.descriptions?.map(description => ({
                    lang: description?.lang,
                    value: description?.value
                })),
                metrics: {
                    cvssMetricV2: vulnerability?.cve?.metrics?.cvssMetricV2?.map(metric => ({
                        cvssData: {
                            vectorString:metric?.cvssData?.vectorString,
                            accessVector: metric?.cvssData?.accessVector,
                            accessComplexity: metric?.cvssData?.accessComplexity,
                            authentication: metric?.cvssData?.authentication,
                            confidentialityImpact: metric?.cvssData?.confidentialityImpact,
                            integrityImpact: metric?.cvssData?.integrityImpact,
                            availabilityImpact: metric?.cvssData?.availabilityImpact,
                        },
                        baseSeverity: metric?.baseSeverity,
                        exploitabilityScore: metric?.exploitabilityScore,
                        impactScore: metric?.impactScore

                    }))
                },
                
                configurations: configurations
            };
            cveDataArray.push(cveData);

            await CVE.create(cveData);
        }
       

        cveDataArray.forEach(cve => {
            cve.published = new Date(cve.published);
        });

        cveDataArray.sort((a, b) => a.published - b.published);

        res.json({ message: "success", data: cveDataArray, totalRecords: vulnerabilities.length});
    } catch (error) {
        console.error('Error fetching and storing CVE data:', error.response ? error.response.data : error);
        res.status(500).json({ error: 'An internal server error occurred' });
    }
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
